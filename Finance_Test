# defterlite_app.py
# Streamlit-based personal finance app inspired by Defter.
# Features
# - Manual income / expense entry with multiple "sources" and **accounts** (ING Giro, Savings, Visa, etc.)
# - Category management (no keywords). Category dropdowns everywhere.
# - Bulk import from PDF (ING Germany Umsatzanzeige supported) and generic single-line PDFs
# - Edit/Delete transactions, with **ID reset to 1** when the table becomes empty
# - Pie chart of expenses by category
# - Local SQLite storage (portable) + CSV/Excel export
# - Optional Google Drive backup via PyDrive2 (OAuth needed)
#
# Quickstart
#   pip install -r requirements.txt  # see REQUIREMENTS block at bottom of file
#   streamlit run defterlite_app.py
#
# Notes
# - For scanned PDFs (images), you'll need OCR (e.g., pytesseract); this app handles text-based PDFs.
# - Google Drive backup requires a Google Cloud OAuth client and a client_secrets.json in the working dir.

import io
import os
import re
import json
import math
import sqlite3
import contextlib
from datetime import datetime, date
from typing import List, Optional, Dict

import pandas as pd
import streamlit as st
import matplotlib.pyplot as plt

# PDF parsing (text-based)
try:
    import pdfplumber
except Exception:
    pdfplumber = None

# Optional Google Drive backup
try:
    from pydrive2.auth import GoogleAuth
    from pydrive2.drive import GoogleDrive
except Exception:
    GoogleAuth = None
    GoogleDrive = None

DB_PATH_DEFAULT = "finance.db"

# ----------------------------
# Database helpers & schema
# ----------------------------

def get_conn(db_path: str):
    conn = sqlite3.connect(db_path, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn

SCHEMA_BASE = """
CREATE TABLE IF NOT EXISTS transactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    t_date TEXT NOT NULL,                 -- ISO date string YYYY-MM-DD
    description TEXT NOT NULL,
    amount REAL NOT NULL,                 -- positive numbers
    t_type TEXT NOT NULL,                 -- 'expense' | 'income'
    category TEXT NOT NULL,
    source TEXT NOT NULL,
    account TEXT NOT NULL DEFAULT 'Main',
    created_at TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS categories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS accounts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE
);
"""

@contextlib.contextmanager
def db_cursor(conn):
    cur = conn.cursor()
    try:
        yield cur
        conn.commit()
    finally:
        cur.close()


def table_has_column(conn, table: str, col: str) -> bool:
    with db_cursor(conn) as cur:
        cur.execute(f"PRAGMA table_info({table})")
        cols = [r[1] for r in cur.fetchall()]
    return col in cols


def init_db(conn):
    with db_cursor(conn) as cur:
        cur.executescript(SCHEMA_BASE)
    # Migrations / defaults
    if not table_has_column(conn, 'transactions', 'account'):
        with db_cursor(conn) as cur:
            cur.execute("ALTER TABLE transactions ADD COLUMN account TEXT NOT NULL DEFAULT 'Main'")
    # Seed default account
    if not pd.read_sql_query("SELECT name FROM accounts", conn).shape[0]:
        with db_cursor(conn) as cur:
            cur.execute("INSERT OR IGNORE INTO accounts(name) VALUES ('Main')")
    # If an old table 'category_rules' existed, migrate its distinct categories
    with db_cursor(conn) as cur:
        cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='category_rules'")
        if cur.fetchone():
            try:
                cats = pd.read_sql_query("SELECT DISTINCT category AS name FROM category_rules", conn)
                for _, r in cats.iterrows():
                    cur.execute("INSERT OR IGNORE INTO categories(name) VALUES (?)", (r['name'],))
                cur.execute("DROP TABLE category_rules")
            except Exception:
                pass

# ----------------------------
# CRUD helpers
# ----------------------------

def list_categories(conn) -> List[str]:
    df = pd.read_sql_query("SELECT name FROM categories ORDER BY name", conn)
    return df['name'].tolist()


def add_category(conn, name: str):
    with db_cursor(conn) as cur:
        cur.execute("INSERT OR IGNORE INTO categories(name) VALUES (?)", (name.strip(),))


def delete_categories(conn, names: List[str]):
    with db_cursor(conn) as cur:
        for n in names:
            cur.execute("DELETE FROM categories WHERE name=?", (n,))


def list_accounts(conn) -> List[str]:
    df = pd.read_sql_query("SELECT name FROM accounts ORDER BY name", conn)
    return df['name'].tolist()


def add_account(conn, name: str):
    with db_cursor(conn) as cur:
        cur.execute("INSERT OR IGNORE INTO accounts(name) VALUES (?)", (name.strip(),))


def update_transaction(conn, row: Dict):
    with db_cursor(conn) as cur:
        cur.execute(
            """
            UPDATE transactions SET t_date=?, description=?, amount=?, t_type=?, category=?, source=?, account=?
            WHERE id=?
            """,
            (row['t_date'], row['description'], float(row['amount']), row['t_type'], row['category'], row['source'], row['account'], int(row['id']))
        )


def delete_transactions(conn, ids: List[int]):
    if not ids:
        return
    with db_cursor(conn) as cur:
        cur.executemany("DELETE FROM transactions WHERE id=?", [(int(i),) for i in ids])
    # Reset auto-increment sequence when table becomes empty so next id starts at 1 again
    with db_cursor(conn) as cur:
        cur.execute("SELECT COUNT(*) FROM transactions")
        cnt = cur.fetchone()[0]
        if cnt == 0:
            # Reset sqlite_sequence entry for transactions
            cur.execute("DELETE FROM sqlite_sequence WHERE name='transactions'")
            # VACUUM helps reclaim space; harmless if not permitted
            try:
                cur.execute("VACUUM")
            except Exception:
                pass


def insert_transaction(conn, t_date: str, description: str, amount: float, t_type: str, category: str, source: str, account: str):
    with db_cursor(conn) as cur:
        cur.execute(
            """
            INSERT INTO transactions (t_date, description, amount, t_type, category, source, account, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """,
            (t_date, description.strip(), amount, t_type, category.strip(), source.strip(), account.strip(), datetime.utcnow().isoformat()),
        )


def fetch_transactions_df(conn, start_date: Optional[str] = None, end_date: Optional[str] = None, source: Optional[str] = None, account: Optional[str] = None):
    q = "SELECT * FROM transactions WHERE 1=1"
    params = []
    if start_date:
        q += " AND t_date >= ?"; params.append(start_date)
    if end_date:
        q += " AND t_date <= ?"; params.append(end_date)
    if source and source != "All":
        q += " AND source = ?"; params.append(source)
    if account and account != "All":
        q += " AND account = ?"; params.append(account)
    q += " ORDER BY date(t_date) DESC, id DESC"
    df = pd.read_sql_query(q, conn, params=params)
    return df

# ----------------------------
# PDF parsing utilities (ING-aware)
# ----------------------------

LINE_ITEM_REGEXES = [
    re.compile(r"(?P<date>\d{4}-\d{2}-\d{2})\s+(?P<desc>.+?)\s+(?P<amount>[+\-]?\d+[\.,]\d{2})(?:\s*€)?$"),
    re.compile(r"(?P<date>\d{2}/\d{2}/\d{4})\s+(?P<desc>.+?)\s+(?P<amount>[+\-]?\d+[\.,]\d{2})(?:\s*€)?$"),
]

AMOUNT_RE_EU = re.compile(r"([+\-]?)((?:\d{1,3}(?:[\.\s]\d{3})*|\d+),\d{2})")
DATE_DE_RE   = re.compile(r"^(\d{2})\.(\d{2})\.(\d{4})$")


def _parse_amount_eu(s: str) -> Optional[float]:
    m = AMOUNT_RE_EU.search(s)
    if not m:
        return None
    sign, num = m.groups()
    num = num.replace(".", "").replace(" ", "").replace(",", ".")
    val = float(num)
    return -val if sign == '-' else val


def _parse_date_mixed(s: str) -> Optional[date]:
    s = s.strip()
    m = DATE_DE_RE.match(s)
    if m:
        d, mth, y = map(int, m.groups())
        return date(y, mth, d)
    for fmt in ("%Y-%m-%d", "%d/%m/%Y"):
        try:
            return datetime.strptime(s, fmt).date()
        except Exception:
            pass
    return None


def parse_pdf_bytes(pdf_bytes: bytes) -> pd.DataFrame:
    """Parser with special handling for ING Germany 'Umsatzanzeige'."""
    if pdfplumber is None:
        st.warning("pdfplumber not installed; can't parse PDF. See REQUIREMENTS block.")
        return pd.DataFrame(columns=["t_date", "description", "amount", "t_type"])

    # Collect lines
    lines: List[str] = []
    with pdfplumber.open(io.BytesIO(pdf_bytes)) as pdf:
        for page in pdf.pages:
            text = page.extract_text() or ""
            lines.extend([ln.rstrip() for ln in text.splitlines()])

    # Strategy A — ING multi-line rows
    rows = []
    i = 0
    while i < len(lines):
        ln = lines[i].strip()
        d1 = _parse_date_mixed(ln)
        d2 = _parse_date_mixed(lines[i+1].strip()) if (d1 and i+1 < len(lines)) else None
        if d1 and d2:
            j = i + 2
            desc_parts: List[str] = []
            while j < len(lines):
                cur = lines[j].strip()
                if not cur:
                    j += 1
                    continue
                amt = _parse_amount_eu(cur)
                if amt is not None and ('€' in cur or AMOUNT_RE_EU.search(cur)):
                    all_amts = list(AMOUNT_RE_EU.finditer(cur))
                    if all_amts:
                        sign, num = all_amts[-1].groups()
                        num = num.replace('.', '').replace(' ', '').replace(',', '.')
                        amt_val = float(num)
                        if sign == '-':
                            amt_val = -amt_val
                    else:
                        amt_val = float(amt)
                    description = " ".join(desc_parts).strip() or "Unbekannt"
                    ttype = "expense" if amt_val < 0 else "income"
                    rows.append({
                        "t_date": d1.isoformat(),
                        "description": description,
                        "amount": abs(amt_val),
                        "t_type": ttype,
                    })
                    i = j
                    break
                else:
                    if not ("Saldo" in cur and "Betrag" in cur):
                        if len(desc_parts) < 3:
                            desc_parts.append(cur)
                    j += 1
            i += 1
        else:
            i += 1

    if rows:
        return pd.DataFrame(rows)

    # Strategy B — fallback single-line
    fallback_rows = []
    for raw_line in lines:
        line = raw_line.strip()
        for rx in LINE_ITEM_REGEXES:
            m = rx.search(line)
            if m:
                d = m.groupdict()
                dt = _parse_date_mixed(d["date"]) or date.today()
                amt = float(d["amount"].replace(",", ".").replace(" ", ""))
                fallback_rows.append({
                    "t_date": dt.isoformat(),
                    "description": d["desc"],
                    "amount": abs(amt),
                    "t_type": "expense" if amt < 0 else "income",
                })
                break
    return pd.DataFrame(fallback_rows)

# ----------------------------
# UI helpers
# ----------------------------

def ensure_state_defaults():
    if "db_path" not in st.session_state:
        st.session_state.db_path = DB_PATH_DEFAULT
    if "conn" not in st.session_state:
        st.session_state.conn = get_conn(st.session_state.db_path)
        init_db(st.session_state.conn)


def header():
    st.title("DefterLite — Personal Finance")
    st.caption("Manual entries, PDF imports, categories, accounts, charts, backups. Portable and friendly.")


def sidebar_controls():
    st.sidebar.subheader("Storage")
    db_path = st.sidebar.text_input("SQLite file", st.session_state.db_path, help="Path to the local SQLite database file.")
    if db_path != st.session_state.db_path:
        st.session_state.db_path = db_path
        st.session_state.conn = get_conn(db_path)
        init_db(st.session_state.conn)
        st.sidebar.success(f"Connected to {db_path}")

    st.sidebar.divider()
    st.sidebar.subheader("Date Range")
    d1 = st.sidebar.date_input("Start", value=date(date.today().year, 1, 1))
    d2 = st.sidebar.date_input("End", value=date.today())
    st.sidebar.divider()

    st.sidebar.subheader("Filters")
    df_sources = pd.read_sql_query("SELECT DISTINCT source FROM transactions ORDER BY source", st.session_state.conn)
    sources = ["All"] + sorted(df_sources["source"].dropna().tolist()) if not df_sources.empty else ["All"]
    src = st.sidebar.selectbox("Source", options=sources)
    accounts = ["All"] + list_accounts(st.session_state.conn)
    acct = st.sidebar.selectbox("Account", options=accounts)

    return d1.isoformat(), d2.isoformat(), src, acct


def manual_entry_form(conn):
    st.header("Add Transaction")
    with st.form("manual_entry"):
        c1, c2, c3 = st.columns(3)
        t_date = c1.date_input("Date", value=date.today()).isoformat()
        t_type = c2.selectbox("Type", ["expense", "income"], index=0)
        amount = c3.number_input("Amount", min_value=0.0, step=0.01, format="%.2f")
        description = st.text_input("Description")
        source = st.text_input("Source", value="manual", help="e.g., cash, bank:Revolut, card:Visa")
        # Categories dropdown (no keywords)
        cats = list_categories(conn)
        csel = st.selectbox("Category", options=(cats + ["Uncategorized"]))
        # Account dropdown
        acct = st.selectbox("Account", options=list_accounts(conn))
        submitted = st.form_submit_button("Add")
        if submitted:
            if not description.strip():
                st.error("Description is required.")
            elif amount <= 0:
                st.error("Amount must be > 0.")
            else:
                insert_transaction(conn, t_date, description, amount, t_type, csel, source, acct)
                st.success("Saved.")


def categories_manager(conn):
    st.header("Categories")
    st.caption("Maintain a flat list of categories. Transactions choose from this list.")
    with st.form("add_category"):
        c1, c2 = st.columns([3,1])
        name = c1.text_input("New category", placeholder="e.g., Groceries, Rent, Fuel")
        add = c2.form_submit_button("Add")
        if add and name.strip():
            add_category(conn, name.strip())
            st.success("Category added.")
    cats = list_categories(conn)
    if cats:
        to_del = st.multiselect("Delete categories", cats)
        if st.button("Delete selected categories"):
            delete_categories(conn, to_del)
            st.success("Deleted.")
    else:
        st.info("No categories yet. Add your first one above.")


def pdf_importer(conn):
    st.header("Bulk import from PDF")
    if pdfplumber is None:
        st.warning("Install pdfplumber to enable PDF import. See REQUIREMENTS block.")
        return

    uploaded = st.file_uploader("Upload a text-based PDF (bank statement or exported list)", type=["pdf"])
    if uploaded is not None:
        pdf_bytes = uploaded.read()
        df = parse_pdf_bytes(pdf_bytes)
        if df.empty:
            st.warning("No transactions detected. This build supports ING 'Umsatzanzeige' and simple single-line PDFs.")
            return
        st.subheader("Parsed preview")
        default_cat = st.selectbox("Default category for these items", options=(list_categories(conn) + ["Uncategorized"]))
        default_acct = st.selectbox("Account for this batch", options=list_accounts(conn))
        default_source = st.text_input("Source for this batch", value="import:pdf")
        # Apply defaults
        df["category"] = default_cat
        df["source"] = default_source
        df["account"] = default_acct
        st.dataframe(df)
        if st.button("Import these transactions"):
            for _, r in df.iterrows():
                insert_transaction(conn, r["t_date"], r["description"], float(r["amount"]), r["t_type"], r["category"], r["source"], r["account"])
            st.success(f"Imported {len(df)} rows.")


def analytics(conn, start_date: str, end_date: str, source_filter: Optional[str], account_filter: Optional[str]):
    st.header("Overview & Analytics")
    df = fetch_transactions_df(conn, start_date, end_date, source_filter, account_filter)
    if df.empty:
        st.info("No transactions in this range.")
        return

    c1, c2, c3 = st.columns(3)
    total_exp = df.query("t_type=='expense'")["amount"].sum()
    total_inc = df.query("t_type=='income'")["amount"].sum()
    balance = total_inc - total_exp
    c1.metric("Total Expenses", f"{total_exp:,.2f}")
    c2.metric("Total Income", f"{total_inc:,.2f}")
    c3.metric("Balance", f"{balance:,.2f}")

    st.subheader("Transactions")
    st.dataframe(df)

    exp = df[df["t_type"]=="expense"]
    if not exp.empty:
        by_cat = exp.groupby("category")["amount"].sum().sort_values(ascending=False)
        fig, ax = plt.subplots()
        ax.pie(by_cat.values, labels=by_cat.index, autopct='%1.1f%%', startangle=90)
        ax.axis('equal')
        st.pyplot(fig)
    else:
        st.info("No expenses in this selection to chart.")

# ----------------------------
# Edit tab (inline editor with delete & ID reset on empty)
# ----------------------------

def edit_view(conn, start_date: str, end_date: str, source_filter: Optional[str], account_filter: Optional[str]):
    st.header("Edit / Delete Transactions")
    df = fetch_transactions_df(conn, start_date, end_date, source_filter, account_filter)
    if df.empty:
        st.info("No transactions to edit for this filter.")
        return

    # Make editable copy
    editable = df.copy()
    # Constrain columns and dropdowns
    editable["t_type"] = editable["t_type"].astype("category")
    type_opts = ["expense", "income"]
    cat_opts = list_categories(conn) + ["Uncategorized"]
    acct_opts = list_accounts(conn)

    edited = st.data_editor(
        editable,
        column_config={
            "t_type": st.column_config.SelectboxColumn("Type", options=type_opts),
            "category": st.column_config.SelectboxColumn("Category", options=cat_opts),
            "account": st.column_config.SelectboxColumn("Account", options=acct_opts),
        },
        disabled=["id", "created_at"],
        num_rows="dynamic",
        use_container_width=True,
        key="editor_grid",
    )

    c1, c2 = st.columns([1,1])
    if c1.button("Save edits"):
        for _, row in edited.iterrows():
            update_transaction(conn, row)
        st.success("Edits saved.")

    ids_to_delete = st.multiselect("Select IDs to delete", edited["id"].tolist())
    if c2.button("Delete selected"):
        delete_transactions(conn, ids_to_delete)
        st.success("Deleted. If the table became empty, the next new row will have ID = 1.")

# ----------------------------
# Accounts view: balances & transfers
# ----------------------------

def account_balances(conn, start_date: Optional[str] = None, end_date: Optional[str] = None):
    accounts = list_accounts(conn)
    rows = []
    for acct in accounts:
        q = "SELECT t_type, SUM(amount) as total FROM transactions WHERE account=?"
        params = [acct]
        if start_date:
            q += " AND t_date >= ?"; params.append(start_date)
        if end_date:
            q += " AND t_date <= ?"; params.append(end_date)
        q += " GROUP BY t_type"
        df = pd.read_sql_query(q, conn, params=params)
        inc = float(df[df["t_type"]=="income"]["total"].sum()) if not df.empty else 0.0
        exp = float(df[df["t_type"]=="expense"]["total"].sum()) if not df.empty else 0.0
        rows.append({"account": acct, "income": inc, "expense": exp, "balance": inc-exp})
    return pd.DataFrame(rows)


def transfer_form(conn):
    st.subheader("Transfer between accounts")
    accts = list_accounts(conn)
    if len(accts) < 2:
        st.info("Create at least two accounts to transfer between them.")
        return
    c1, c2, c3, c4 = st.columns(4)
    t_date = c1.date_input("Date", value=date.today()).isoformat()
    from_acct = c2.selectbox("From", options=accts, index=0)
    to_acct = c3.selectbox("To", options=[a for a in accts if a != from_acct])
    amount = c4.number_input("Amount", min_value=0.0, step=0.01, format="%.2f")
    note = st.text_input("Note", value="Transfer")
    if st.button("Record transfer"):
        if amount <= 0:
            st.error("Amount must be > 0.")
        elif from_acct == to_acct:
            st.error("From and To accounts must differ.")
        else:
            insert_transaction(conn, t_date, note, amount, "expense", "Transfer Out", "transfer", from_acct)
            insert_transaction(conn, t_date, note, amount, "income", "Transfer In", "transfer", to_acct)
            st.success("Transfer recorded.")


def accounts_view(conn, start_date: Optional[str], end_date: Optional[str]):
    st.header("Accounts")
    with st.expander("Add account"):
        new_acct = st.text_input("Account name", placeholder="e.g., ING Giro, Savings, Visa")
        if st.button("Create account") and new_acct.strip():
            add_account(conn, new_acct.strip())
            st.success("Account created.")
    df = account_balances(conn, start_date, end_date)
    if df.empty:
        st.info("No accounts yet.")
        return
    st.subheader("Balances")
    st.dataframe(df)
    transfer_form(conn)

# ----------------------------
# Main
# ----------------------------

def main():
    ensure_state_defaults()
    header()
    start_date, end_date, source_filter, account_filter = sidebar_controls()

    tab1, tab2, tab3, tab4, tab5, tab6 = st.tabs(["Add", "Import PDF", "Categories", "Edit", "Analytics", "Accounts"])
    with tab1:
        manual_entry_form(st.session_state.conn)
    with tab2:
        pdf_importer(st.session_state.conn)
    with tab3:
        categories_manager(st.session_state.conn)
    with tab4:
        edit_view(st.session_state.conn, start_date, end_date, source_filter, account_filter)
    with tab5:
        analytics(st.session_state.conn, start_date, end_date, source_filter, account_filter)
    with tab6:
        accounts_view(st.session_state.conn, start_date, end_date)


if __name__ == "__main__":
    main()

# ----------------------------
# REQUIREMENTS (put this in requirements.txt)
# ----------------------------
# streamlit>=1.38
# pandas>=2.0
# matplotlib>=3.7
# pdfplumber>=0.11
# pydrive2>=1.16
# xlsxwriter>=3.2
